<html>
	<head>
		<title>QuakeD - Modifying Quake 3 - The Homing Missile Approach - Game Development </title>
		<STYLE> BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
	H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
	H2 { font-size: 13pt; }
	H3 { font-size: 12pt; }
	H4 { font-size: 10pt; color: black; }
	PRE { BACKGROUND-COLOR: #F5F5F5; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
	CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
	</STYLE>


<script language="JavaScript1.2" src="/menu/menu.js"></script>
<link href="/menu/include_menu.css" rel="stylesheet" type="text/css" />


	</head>
	<body>
		<table id="Table1">
			<tr border="0">
<td width='12px' valign=top border=2 > &nbsp;</td>
				<td colSpan="2">
					<table id="Table2" style="BACKGROUND-IMAGE: url(images/Header-Background.jpg)" cellSpacing="0"
						cellPadding="0" width="100%">
						<tr>
							<td vAlign="middle" align="center"><IMG src="images/quake3title.jpg">
							</td>
							<td vAlign="top"><br>
								<strong>
									<span style="FONT-SIZE: 12pt; COLOR: blue">
										<span style="FONT-SIZE: 16pt; COLOR: dimgray; FONT-FAMILY: Comic Sans MS">Modifying Quake 3 - The Homing Missile Approach 
            <br></span>
										<br>
										<hr>
										<span style="FONT-SIZE: 10pt; COLOR: #000000; FONT-FAMILY: Verdana">Author: Anup Shinde.</span>
									</span></strong></td>
						</tr>
					</table>
				</td>
			</tr>
			<tr border="0">
<td width='12px' valign=top border=2 > &nbsp;</td>
				<td vAlign="top" border="0">
					<P><br>
					</P>
					<P>
						<hr>
					<P></P>
					<P><br>
						<STRONG>Introduction</STRONG>
					</P>
					<P>In this article I have shown how to compile and modify the Quake 3 source code 
						to create a Homing Missile. This article is intended for beginners.</P>
					<P><STRONG>Background</STRONG></P>
					<P>
						Quake&nbsp;III&nbsp;was released few years back (somewhere in 2001-2002 if I am 
						not wrong). At the same time, I was looking forward to buy a new PC and while 
						researching for the same, I got a computer magazine with Quake III demo. That's 
						when I decided that Quake III was going to be my benchmark for the new 
						PC.&nbsp;Excellent game and my favorite till date. Now let me stop telling 
						stories and get back to the point.
					</P>
					<P><STRONG>Source code</STRONG></P>
					<P>Quake3's source code was launched some time after its release. The code does not 
						have a hell lot of comments, but its very readable and understandable. You must 
						know C and a bit of 3D vector mathematics. Mathematics I suppose can be learnt 
						in case you don't have that background. At times you might get stuck in 
						understanding the code due to vector operations performed. Just take a pen and 
						paper and calculate it down, life will be much easier with those two objects.</P>
					<P>The entire source code has not been released. Though I don't know which part, a 
						major part like the rendering engine could be under cover.
					</P>
					<P>Quake3's 3D engine has been proven as one of the best 3D engines made and some 
						people have also said that nobody can write better code than the one written 
						for this engine. Recently I also had a chance to go through the Microsoft 
						Techfest, in which, one of the demonstrated research project was based on Quake 
						III. FYI: It was regarding improving multiplayer gaming performance over a low 
						bandwidth network around 100kbps. So, there is a lot of potential in reusing 
						its code if your research/application requirements fit the same.
					</P>
					<P><U>NOTE:</U> Quake 3's source code is free does not mean that it's game data is 
						free. And you cannot play game without the game data (maps, sounds, music, bot 
						models, etc.)That's why you still need to buy an original Quake 3 CD.</P>
					<P><STRONG>Why am I re-writing this?</STRONG></P>
					<P>You will find many websites with bits and pieces of information for compiling 
						and modifying Quake 3 source. Inadequate or incorrect informations leads to 
						frustration most of the time as it was the case with me. It took a lot of time 
						for me to finally compile and run quake 3 from the compiled code. Creating mods 
						(relatively means modifying source) is another story, but that was fun. The 
						code-change illustrated here again took a lot of time. Understanding and 
						tweaking the code given here is also a good way of learning some basics about 
						this game.<EM>&nbsp; </EM>
					</P>

<table width=100%><tr><td align=center>

<script type="text/javascript"><!--
google_ad_client = "pub-7512590957470103";
google_ad_width = 728;
google_ad_height = 90;
google_ad_format = "728x90_as";
google_ad_type = "text";
google_ad_channel = "";
google_color_border = "F6F6F6";
google_color_bg = "F5F5F5";
google_color_link = "0000FF";
google_color_text = "000000";
google_color_url = "008000";
//-->
</script>
<script type="text/javascript"
  src="http://pagead2.googlesyndication.com/pagead/show_ads.js">
</script>

</td></tr></table>

					<P></P>
					<P><STRONG>Compiling the source code</STRONG></P>
					<P>You won't&nbsp;find the entire source code&nbsp;here, but you can download it 
						from <a href="http://www.idsoftware.com/" target="_blank"><U>Id software's&nbsp;website</U></a>
					.
					<P>Attached are the <a href="others/q3_mod_code.zip">source files</a> for the 
						modifications. You can also see the compiled Mods <a href="others/q3ModDll.zip">here</a>
					.
					<P>Before you start, it is also important to check the following:
						<UL>
							<LI>
								You have a <FONT color="brown">full version of Quake 3 </FONT>
							already installed. (Demo version won't work for us)
							<LI>
								Download <FONT color="brown"><EM>Quake 3 point release 1.32</EM> </FONT>
							from the website and install it to your Quake 3 game directory.
							<LI>
								Check that you have Visual Studio 2003 installed on your machine. If you don't 
								have VS2k3 and use VC++6.0, life's a bit difficult. Please see if <a href="others/vcpp6inst.htm" target="_blank">
									this</a> helps.</LI></UL>
					<P>Now follow the steps given below to complie the source code.</P>
					<UL>
						<LI>
							Download the <EM>Quake 3 source </EM>
						from ID software and extract it to some directory.
						<LI>
							Under the <EM>Code</EM> subdirectory, load the solution file <EM>quake3.sln </EM>
						in VS 2003. ( In case of VC++6.0 see the above mentioned link).
						<LI>
							It is a source control bound code; therefore it will give some errors and ask 
							for some source control server. Just click <EM>Cancel </EM>
						when it asks for the source control and just unbind all the projects from 
						source control. (I don't know why Q3 team didn't do this).
						<LI>
							Select <EM>Release </EM>from <EM>Build -&gt; Configuration Manager </EM>and 
							build the solution. It should build without any errors. Verify the files 
							created in the <EM>Code-&gt;Release</EM>. It should build without any errors. 
							Verify the files created in the <EM>Code-&gt;Release</EM>.
						<LI>
							Go to the directory where you have installed <EM>Quake 3</EM>. Within that, 
							create a new directory <EM>“Mod”</EM>
						(of course without the quotes).
						<LI>
							Go back to the <EM>Release</EM> directory and copy all the DLLs and EXEs 
							(only&nbsp;one&nbsp;EXE:&nbsp;<EM>quake3.exe </EM>exists). Paste these files in 
							the newly created <EM>Mod</EM>
						directory.
						<LI>
							Now go to the <EM>Quake 3 </EM>directory. Here again you will find <EM>Quake3.exe</EM>. 
							This is the one that was installed from your Quake 3 CD. Rename it to <EM>Quake3.exe.backup</EM>.
						<LI>
							Move the <EM>Quake3.exe</EM> from Mod directory to the current <EM>Quake 3 </EM>
						directory. (If you are confused with same kind of names, please re-read.)
						<LI>
							Go back to the <EM>Mod</EM> directory and create a new batch file <EM>"runrelease.bat"</EM>
							and write following lines in it.
							<pre>cd..
quake3 +set fs_game Mod 
						</pre>
							This tells the quake3 executable to load the game with our code.</LI></UL>
					<P>&nbsp;</P>
					<P>Now to run the game with your compiled code, just double-click the batch file, 
						and you are ready to play. An important step has been covered by this time.
					</P>
					<P>&nbsp;</P>
					<P><U>NOTE:</U> Debugging is (as usual) possible in Quake 3 too. That is not 
						covered in this article.</P>
					<P><U>NOTE:</U> Actually you don’t need to change the exe until you want some 
						changes in the quake3 EXE project code. But I recommend this since I have 
						noticed sometimes the original EXE takes a lot of time to load when we 
						implement our modifications.</P>
					<P><U>WARNING:</U> While making your modifications it is recommended to run Quake 3 
						in windowed mode ( and not the normal full screen mode). You can switch to 
						windowed mode by the pressing <EM>Alt+Enter</EM>. Quake 3 remembers the 
						configuration (atleast on my PC) while loading the next time. Runtime errors 
						may hang up your inputs in full screen mode and thereby forcing you to restart 
						without proper shutdown.</P>
					<P>&nbsp;</P>
					<P><STRONG>Before you modify the code (some basics)</STRONG></P>
					<P>It is important to understand some concepts of Quake 3 before you modify the 
						code. Here I am defining only very small part required to understand the code 
						illustrated here. There are lots of things that you will find out once you have 
						started&nbsp;doing more than what's presented here.
					</P>
					<P>Anything that is created in the game is called an entity. Every entity created 
						in Quake 3 has an associated <EM>think </EM>function. The <EM>think </EM>function 
						defines the kind of behavior the entity will exhibit at various <EM>times </EM>in 
						the game.
					</P>
					<P>For example if you see the <EM>fire_rocket</EM> method in <EM>g_missile.c </EM>under 
						the <EM>game </EM>project (under <EM>quake3.sln)</EM>, you will find lines 
						stating:
					</P>
					<PRE>bolt-&gt;nextthink = level.time + 15000;					
bolt-&gt;think = G_ExplodeMissile; //Game time here is in milliseconds.
					</PRE>
					<P>G_ExplodeMissle is a think function for the rocket. This means that after 15 
						seconds the rocket will explode. Let us call this time frame as the Next Think 
						time.
					</P>
					<P>We can have our own think function that will define what the rocket will do 
						after a time specified. By default a missile entity doesn’t require processing 
						once released, but depending on the entity type and its behavior , the next 
						think time can be different.
					</P>
					<P>&nbsp;</P>
					<P><STRONG>The Homing Missile</STRONG></P>
					<P>By definition, homing missile is a kind of missile which when fired will find a 
						nearest target and steer itself towards it and finally blast into the target.</P>
					<P>In Quake 3, we will enable firing of <EM>homing missile </EM>from the <EM>rocket 
							launcher</EM> itself. A player can select whether he wants to fire a <EM>simple 
							rocket </EM>or <EM>homing missile </EM>(same rocket behaving differently).</P>
					<P>We can divide this task into two parts:</P>
					<UL>
						<LI>
						Taking inputs from the player on what kind of rocket to use (homing or simple)
						<LI>
							Creating a think function to change the behavior of missile.</LI></UL>
					<P><STRONG><EM>Taking inputs from the player </EM></STRONG>
					</P>
					<P>First we must have a place where we can store the input of the player. 
						Therefore, we insert a variable <EM><FONT color="brown">homingMissle</FONT></EM>
						in <EM><FONT color="brown">clientPersistant_t</FONT></EM> typed structure. This 
						structure is declared in the file <EM><FONT color="brown">g_local.h</FONT> </EM>
						under the <EM>game </EM>project. The changed structure&nbsp;is shown below.</P>
					<PRE>// client data that stays across multiple respawns, but is cleared
// on each level change or team change at ClientBegin()
typedef struct {
	clientConnected_t	connected;	
	usercmd_t		cmd;			// we would lose angles if not persistant
	qboolean		localClient;		// true if "ip" info key is "localhost"
	qboolean		initialSpawn;		// the first spawn should be at a cool location
	qboolean		predictItemPickup;	// based on cg_predictItems userinfo
	qboolean		pmoveFixed;		//
	char			netname[MAX_NETNAME];
	int			maxHealth;		// for handicapping
	int			enterTime;		// level.time the client entered the game
	playerTeamState_t 	teamState;		// status in teamplay games
	int			voteCount;		// to prevent people from constantly calling votes
	int			teamVoteCount;		// to prevent people from constantly calling votes
	qboolean		teamInfo;		// send team overlay updates?
<STRONG>	int			homingMissle;		// is homing missle on for the client
</STRONG>
} clientPersistant_t;
</PRE>
					<P>You must be wondering why I am using <EM>int</EM> when I can use a <EM>boolean. </EM>
						That's because in the code I am also introducing different types of homing 
						missiles. Their think functions are different. I will be explaining only the 
						basic homing missile code here.</P>
					<P>Once we have placed a varible here, we must initialize it with a default value 
						whenever a new player is created. This is done in function <EM><FONT color="brown">ClientBegin(...)</FONT></EM>
						in file <FONT color="brown"><EM>g_client.c</EM></FONT> as shown below.</P>
					<PRE>void ClientBegin( int clientNum ) {
	gentity_t	*ent;
	...........
	ent-&gt;client = client;

<STRONG>	client-&gt;pers.homingMissle = 0;
</STRONG>	client-&gt;pers.connected = CON_CONNECTED;
	client-&gt;pers.enterTime = level.time;

	...........
	// count current clients and rank for scoreboard
	CalculateRanks();
}
</PRE>
					<P>Now, we have to take input from the player during the game and set it to the <EM>homingMissile
						</EM>variable. If you have played Quake 3, you will know that commands can be 
						given by the sequence "<EM>Press '~'</EM>. Then give command as "<EM>/CommandName 
							command-parameters(if any)</EM>". So lets say our command name is <EM><FONT color="brown">
								homing</FONT></EM>.
					</P>
					<P>We will not be using any parameters with the command. So this variable can be 
						toggled within its value-range. The range used in this code is from 0 to 5. 
						i.e. When the player intiates game the value is 0. Then when player gives <EM>homing</EM>
						command, the value is 1. Thereafter, 2,3,4,5 and finally after 5 it will be 
						back to 0.</P>
					<P>To achieve such functionality, we will have to introduce our command in the file <EM>
							<FONT color="brown">g_cmds.c</FONT></EM>.This we do by modifying the method <EM>
							<FONT color="brown">ClientCommand(...)</FONT></EM> in this file.</P>
					<PRE>void ClientCommand( int clientNum ) {
	gentity_t *ent;
	............
	else if (Q_stricmp (cmd, "stats") == 0)
		Cmd_Stats_f( ent );
<STRONG>	else if (Q_stricmp (cmd, "homing") == 0)
		Cmd_SetHoming_f (ent);
</STRONG>	else
		trap_SendServerCommand( clientNum, va("print \"unknown cmd %s\n\"", cmd ) );
}
</PRE>
					<P>&nbsp;</P>
					<P>As you can see we also used a new method <EM><FONT color="brown">Cmd_SetHoming_f(...)</FONT></EM>. 
						This is declared as shown below</P>
					<PRE><STRONG>//New method added</STRONG>
void Cmd_SetHoming_f (gentity_t *ent)
{
	//0 -&gt; off
	//1 -&gt; Constant speed
	//2 -&gt; Variable speed
	//3 -&gt; Fireworks with varible speed
	//4 -&gt; Fireworks with varible speed and wide angle
	//5 -&gt; Fireworks with varible speed and all view

	if (ent-&gt;client-&gt;pers.homingMissle == 0)
	{
		trap_SendServerCommand( ent-g_entities, va("print \"Homing Missiles with constant speed 
		                                                    are on.\n\""));
		ent-&gt;client-&gt;pers.homingMissle = 1;
	}
	else if (ent-&gt;client-&gt;pers.homingMissle == 1)
	{
		trap_SendServerCommand( ent-g_entities, va("print \"Homing Missiles with variable speed 
		                                                    are on.\n\""));
		ent-&gt;client-&gt;pers.homingMissle = 2;
	}
	else if (ent-&gt;client-&gt;pers.homingMissle == 2)
	{
		trap_SendServerCommand( ent-g_entities, va("print \"Homing Missiles with variable speed 
		                                                    and fireworks are on.\n\""));
		ent-&gt;client-&gt;pers.homingMissle = 3;
	}
	else if (ent-&gt;client-&gt;pers.homingMissle == 3)
	{
		trap_SendServerCommand( ent-g_entities, va("print \"Homing Missiles with variable speed, 
		                                                    fireworks and wide angle are on.\n\""));
		ent-&gt;client-&gt;pers.homingMissle = 4;
	}
	else if (ent-&gt;client-&gt;pers.homingMissle == 4)
	{
		trap_SendServerCommand( ent-g_entities, va("print \"Homing Missiles with variable speed,
		                                                    fireworks and all view are on.\n\""));
		ent-&gt;client-&gt;pers.homingMissle = 5;
	}
	else
	{
		trap_SendServerCommand( ent-g_entities, va("print \"Homing Missiles are off.\n\""));
		ent-&gt;client-&gt;pers.homingMissle = 0;
	}
}

</PRE>
					<P>So now whenever the player gives command <EM>"/homing"</EM>, the values will be 
						toggled within the range and appropriate behavior will be exhibited by the 
						missiles. You can also bind some key say <EM>'h'</EM> to the homing command. Give the command <EM>/bind h homing</EM> </P>.
					<P>As you can see, different values have different behaviors stated.&nbsp;The 
						behavior for <EM>value=1</EM>&nbsp;will be explained here, the rest will be 
						briefly stated later.</P>
					<P>&nbsp;</P>
					<P><STRONG><EM>Changing the behavior of the new missile</EM></STRONG></P>
					<P>Now once we are done with accepting input, we need to change the behavior of the 
						missile based on this value. As discussed before, to achieve this we will have 
						create a new think function that will have the necessary code to exhibit 
						different behavior.</P>
					<P>Re-stating:&nbsp;if you see the <EM><FONT color="brown">fire_rocket</FONT></EM> method 
						in <EM><FONT color="brown">g_missile.c</FONT> </EM>under the <EM><FONT color="brown">game</FONT>
						</EM>project you will find lines stating:
					</P>
					<PRE>bolt-&gt;nextthink = level.time + 15000;					
bolt-&gt;think = G_ExplodeMissile; //Game time here is in milliseconds.
					</PRE>
					<P><EM><FONT color="brown">G_ExplodeMissile</FONT></EM> is a think function for the 
						rocket. This means that after 15 seconds the rocket will explode. 15 seconds is 
						the next think time here.</P>
					<P>We will point it to a different think function <EM><FONT color="brown">missile_think</FONT></EM>. 
						Also a homing&nbsp;missile needs to move a bit slower&nbsp;initially. This is 
						shown below</P>
					<PRE>gentity_t *fire_rocket (gentity_t *self, vec3_t start, vec3_t dir) {
	gentity_t	*bolt;

	............

	bolt-&gt;classname = "rocket";

<STRONG>	//0 -&gt; off
	//1 -&gt; Constant speed
	//2 -&gt; Variable speed
	//3 -&gt; Fireworks with varible speed
	if(self-&gt;client-&gt;pers.homingMissle == 1)
	{
		bolt-&gt;think = missile_think;
		bolt-&gt;nextthink = level.time + 1;
	}
	else if(self-&gt;client-&gt;pers.homingMissle == 2)
	{
		bolt-&gt;think = missile_think_variable_speed;
		bolt-&gt;nextthink = level.time + 1;
	}
	else if(self-&gt;client-&gt;pers.homingMissle == 3 
             || self-&gt;client-&gt;pers.homingMissle == 4 
             || self-&gt;client-&gt;pers.homingMissle == 5)
	{
		bolt-&gt;think = missile_think_variable_speed_fireworks;
		bolt-&gt;nextthink = level.time + 1;
	}
	else
	{
		bolt-&gt;nextthink = level.time + 15000;
		bolt-&gt;think = G_ExplodeMissile;
	}
</STRONG>
	............
	............

	bolt-&gt;s.pos.trType = TR_LINEAR;
	bolt-&gt;s.pos.trTime = level.time - MISSILE_PRESTEP_TIME;	// move a bit on the very first frame
	VectorCopy( start, bolt-&gt;s.pos.trBase );

<STRONG>	if (self-&gt;client-&gt;pers.homingMissle == 1)
	{
		// Initial speed of homing missile has to be less	
		VectorScale( dir, 500, bolt-&gt;s.pos.trDelta ); 
	}
	else
	{
		VectorScale( dir, 900, bolt-&gt;s.pos.trDelta );
	}
</STRONG>


	SnapVector( bolt-&gt;s.pos.trDelta );			// save net bandwidth
	VectorCopy (start, bolt-&gt;r.currentOrigin);

	return bolt;
}
					</PRE>
					<P>The speed is initially set to 500. In my code, the speed increases once target 
						is found, but I feel it is completely personal choice.
					</P>
					<P>Now that we have pointed to another think function, we must define it. Before 
						defining the function, let me explain the behavior that the think function will 
						exhibit in the game environment.</P>
					<UL>
						<LI>
						Defining: The homing missile will select a nearest target, steer towards it and 
						blast into it.
						<LI>
							When the missile is fired and travelling straight, it should scan all the 
							entities in its <EM>visibility distance </EM>and <EM>visual cone</EM>. The 
						visual cone limits the visibility of missile and allows it to become more 
						realistic, else it can just take a 180 degree turn and hit some 
						target&nbsp;behind.
						<LI>
						It should only select other player entities and should not select the 
						firing-player and his team members (in case of team match).
						<LI>
							The target should be directly visible. Since this is a virtual world, the 
							visual cone mathematics does not solve this problem. We need to address it bit 
							differently.</LI></UL>
					<P>The code for this think function is also placed in <FONT color="brown"><EM>g_missile.c</EM></FONT>
						just under the line "<EM><FONT color="brown">#define MISSILE_PRESTEP_TIME 50</FONT></EM>". 
						It is shown below.</P>
					<PRE><EM>#define	MISSILE_PRESTEP_TIME	50</EM>

<STRONG>gentity_t *findNearestTargetInRadius (gentity_t *ent, float rad, vec3_t *pTargetDirectionVector,  
                                      vec3_t missileNormalizedForwardDirection, double fVisionCone)
</STRONG>{
	gentity_t *pEntity = NULL;
	gentity_t *pTarget = NULL;
	vec3_t pEntityMidBodyVector;
	vec_t fEntityMidBodyVectorLengh=0;
	vec_t fTargetDistance=0;
	vec3_t temp_vector;

	trace_t trace;

	// Check for all the entities and find atleast one in radius
	for (pEntity = g_entities; pEntity &lt; &amp;g_entities[level.num_entities]; pEntity++) 
	{
		if (!pEntity-&gt;inuse) // If not on map, continue
			continue;

			// Hit the player in the body and not in feet
			// Add the mins and maxs. Then divide by two. 
			// Add the current origin to it. 
			// That would yeild the middle of the body (bounding box atleast)
			VectorAdd(pEntity-&gt;r.mins,pEntity-&gt;r.maxs,pEntityMidBodyVector); 
			VectorScale(pEntityMidBodyVector,0.5,pEntityMidBodyVector);
			VectorAdd(pEntity-&gt;r.currentOrigin,pEntityMidBodyVector,pEntityMidBodyVector); 

			// Now subtract to get a proper direction.
			VectorSubtract(pEntityMidBodyVector,ent-&gt;r.currentOrigin,pEntityMidBodyVector);

			// We calculated the distance vector above. So this is the distance to entity.
			fEntityMidBodyVectorLengh = VectorLength(pEntityMidBodyVector); 


			// If the distance is greater than the given radius, leave it. 
			if (fEntityMidBodyVectorLengh &gt; rad) 
				continue;

			// Check the entity for different conditions. 
			if(pEntity!=NULL)
			{
				if (!pEntity-&gt;client)
					continue;
				if (pEntity == ent-&gt;parent)
					continue;
				if (pEntity-&gt;health &lt;= 0)
					continue;
				if (pEntity-&gt;client-&gt;sess.sessionTeam == TEAM_SPECTATOR)
					continue;
				if ( OnSameTeam( pEntity, ent-&gt;parent ) ) 
					continue;

				// Normalize the direction vector
				VectorCopy(pEntityMidBodyVector,temp_vector);
				VectorNormalize(temp_vector);

				// Lesser the value of vision cone, wider it will be.
				// Value 1 will narrow down the cone.
				if ( fVisionCone &gt; 0.01 
				     &amp;&amp; 
				     DotProduct(missileNormalizedForwardDirection, temp_vector) &lt; fVisionCone ) 
					   continue;

				// Check if visible
				trap_Trace (&amp;trace, ent-&gt;s.pos.trBase, NULL, NULL, 
				                      pEntity-&gt;s.pos.trBase, ent-&gt;s.number, MASK_SHOT );
				                      
				if ( trace.contents &amp; CONTENTS_SOLID ) // If not visible, then continue
					continue;

				// Passed all the tests, it is a possible target. 
				// Check if there is closer target. 
				// Added 100 so that missle does not change targets 
				// frequently in case of players close to each other
				if ((pTarget == NULL) || (fEntityMidBodyVectorLengh &lt; fTargetDistance+100)) 
				{
					pTarget=pEntity;
					// Copy the direction vector for the think function. 
					// We dont need to recalculate it there.
					VectorCopy(pEntityMidBodyVector, (*pTargetDirectionVector));
					fTargetDistance = fEntityMidBodyVectorLengh;
				}
			}
	}

	return pTarget;
}

<STRONG>void missile_think( gentity_t *ent ) {
</STRONG>
	gentity_t *pTarget = NULL;

	vec3_t targetdir,forward;
	int speed=900;

	VectorCopy(ent-&gt;s.pos.trDelta, forward);
	VectorNormalize(forward);
	pTarget = findNearestTargetInRadius(ent,5000,&amp;targetdir, forward,0.7);

	if(pTarget!=NULL)
	{
		// Steer the missile to the target. 
		// Lower the value in place of 0.05, larger the turning circle.
		VectorMA(forward, 0.05, targetdir, targetdir);
		VectorNormalize(targetdir);
		VectorScale(targetdir, speed, ent-&gt;s.pos.trDelta);
	}

	// These two lines are used to smoothen the missile trajectory. 
	// Removing these will exhibit jerky movement.
	VectorCopy(  ent-&gt;r.currentOrigin ,ent-&gt;s.pos.trBase );
	ent-&gt;s.pos.trTime = level.time;

	ent-&gt;nextthink = level.time + 1;
}


					</PRE>
					<P>I feel the comments placed above are self-explanatory, so not discussing the 
						same. In the attached code, you will find multiple missile_think functions and 
						in total&nbsp;five different homing modes. Here's a brief on those:</P>
					<P><EM><FONT color="brown">Homing Missiles with constant speed</FONT></EM>:
					</P>
					<P>These are the ones shown above. Once launched the missile steers towards the 
						target at same speed.</P>
					<P><EM><FONT color="brown">Homing Missiles with variable speed</FONT></EM>:
					</P>
					<P>I like these one the most and designed for higher precision to hit the target. 
						If the target is far enough, the missile will increase its speed to come close 
						to it. Once it is quite closer, it takes a relative measurement of the angle 
						between itself and target.&nbsp; If angle is too less, missile will again 
						increase its speed and hit the target before it moves out of sight. It is 
						capable of shooting a target in mid-air almost every time.</P>
					<P><EM><FONT color="brown">Homing Missiles with variable speed and fireworks</FONT></EM>:</P>
					<P>Well this idea came from the epic and one time everybody's favorite 
						tele-serial&nbsp;Ramayan, where, in the wars one arrow fired would spawn 
						multiple arrows. Similarly this function facilitates spawning of non-homing 
						rockets when the target is closer. Absolutely no way to escape. Not much 
						interesting to play with. But you'll get to see some great fireworks.</P>
					<P><EM><FONT color="brown">Homing Missiles with variable speed, fireworks and wide angle</FONT></EM>:</P>
					<P>The visual cone is much spread out. Rest is same as above</P>
					<P><EM><FONT color="brown">Homing Missiles with variable speed, fireworks and all view</FONT></EM>:</P>
					<P>Same as above. The visual cone is completely open. Expect the missile to take 
						hair-pin turns when using this.</P>
					<P><STRONG>Concluding...</STRONG>
					</P>
					<P>Here, in the code,&nbsp;I have set some values in code, for the homing missile, 
						such that it works with high precision and the target cannot escape. Now that's 
						a kind of military scenario. In game playing, that will be a real tough 
						scenario and will not be interesting. I leave it upto you to change the code so 
						that the fun part in gaming is not lost.</P>
					<P>Learning Quake 3 can be real fun. Some day it can be used to teach you game 
						development, simulation, 3D geometry and vector mathematics. And besides 
						playing games, its engine can be quite useful for creating 3D UI applications, 
						researching on building architectures,etc.
					</P>
					<P>At many places I have wrongly spelled "Missile" as "Missle". Please excuse that. 
						May be I was hungry for "i" when writing this.</P>
					<P><STRONG>Photo session</STRONG></P>
					<P>Lots of reading and coding. Here are some screen shots.</P>
					<P><IMG src="images/homing_var.gif"></P>
					<P>Grunt being chased by the homing missile</P>
					<P>&nbsp;</P>
					<P><IMG id="IMG1" src="images/homing_fire1.gif"></P>
					<P>Above: Grunt under fire (Homing missile with fireworks).</P>
					<P>Below: Grunt has a narrow escape. Missiles scatter in air.</P>
					<P><IMG src="images/homing_fire2.gif"></P>
					<P><br>
						&nbsp;</P>
					<hr style="FONT-SIZE: 10pt">
					Please do not hesitate to ask queries/suggestions/issues/anything. Click <strong><a onclick="javascript:window.open('/static/anup-contact.htm','','height=225,width=450');return false;"
							href="">
							<span style="COLOR: #3300ff">
								<span style="TEXT-DECORATION: underline">here</span>
							</span></a></strong>for contact information.&nbsp;
					<P></P>
				</td>
			</tr>
		</table>
		<script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
		</script>
		<script type="text/javascript">
_uacct = "UA-665946-1";
urchinTracker();
		</script>
	</body>
</html>
